# coding: utf-8

"""
    Tator REST API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from tator.api_client import ApiClient


class TatorApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def algorithm_launch(self, project, **kwargs):  # noqa: E501
        """algorithm_launch  # noqa: E501

        Start an algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algorithm_launch(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body35 body:
        :return: InlineResponse20110
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.algorithm_launch_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.algorithm_launch_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def algorithm_launch_with_http_info(self, project, **kwargs):  # noqa: E501
        """algorithm_launch  # noqa: E501

        Start an algorithm.  This will create one or more Argo workflows that execute the named algorithm registration. To get a list of available algorithms, use the `Algorithms` endpoint. A media list will be submitted for processing using either a query string or  a list of media IDs. If neither are included, the algorithm will be launched on all media in the project.   Media is divided into batches for based on the `files_per_job` field of the  `Algorithm` object. One batch is submitted to each Argo workflow.  Submitted algorithm jobs may be cancelled via the `Job` or `JobGroup` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.algorithm_launch_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body35 body:
        :return: InlineResponse20110
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method algorithm_launch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `algorithm_launch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AlgorithmLaunch/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20110',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_analysis(self, project, **kwargs):  # noqa: E501
        """create_analysis  # noqa: E501

        Create analysis for a project.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_analysis(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body body:
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_analysis_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_analysis_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_analysis_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_analysis  # noqa: E501

        Create analysis for a project.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_analysis_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body body:
        :return: InlineResponse201
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Analyses/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse201',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_attribute_type(self, project, **kwargs):  # noqa: E501
        """create_attribute_type  # noqa: E501

        Create or list attribute types.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_attribute_type(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body1 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_attribute_type_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_attribute_type_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_attribute_type_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_attribute_type  # noqa: E501

        Create or list attribute types.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_attribute_type_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body1 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_attribute_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_attribute_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AttributeTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_localization(self, project, **kwargs):  # noqa: E501
        """create_localization  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_localization(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body5 body:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_localization_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_localization_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_localization_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_localization  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_localization_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body5 body:
        :return: InlineResponse2012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_localization" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_localization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_localization_type(self, project, **kwargs):  # noqa: E501
        """create_localization_type  # noqa: E501

        Create or retrieve localization types.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_localization_type(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body8 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_localization_type_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_localization_type_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_localization_type_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_localization_type  # noqa: E501

        Create or retrieve localization types.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_localization_type_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body8 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_localization_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_localization_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_media_type(self, project, **kwargs):  # noqa: E501
        """create_media_type  # noqa: E501

        Create or retrieve localization types.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_media_type(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body12 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_media_type_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_media_type_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_media_type_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_media_type  # noqa: E501

        Create or retrieve localization types.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_media_type_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body12 body:
        :return: InlineResponse2011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_media_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_media_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_membership(self, project, **kwargs):  # noqa: E501
        """create_membership  # noqa: E501

        Create or retrieve a list of project memberships.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_membership(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body14 body:
        :return: InlineResponse2013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_membership_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_membership_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_membership_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_membership  # noqa: E501

        Create or retrieve a list of project memberships.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_membership_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body14 body:
        :return: InlineResponse2013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_membership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Memberships/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_obtain_auth_token(self, **kwargs):  # noqa: E501
        """create_obtain_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_obtain_auth_token(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body34 body:
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_obtain_auth_token_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_obtain_auth_token_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_obtain_auth_token_with_http_info(self, **kwargs):  # noqa: E501
        """create_obtain_auth_token  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_obtain_auth_token_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body34 body:
        :return: InlineResponse20042
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_obtain_auth_token" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Token', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project(self, **kwargs):  # noqa: E501
        """create_project  # noqa: E501

        Interact with a list of projects.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Project lists return all projects that the requesting user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body16 body:
        :return: InlineResponse2014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_project_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_project_with_http_info(self, **kwargs):  # noqa: E501
        """create_project  # noqa: E501

        Interact with a list of projects.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Project lists return all projects that the requesting user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body16 body:
        :return: InlineResponse2014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Projects', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_state(self, project, **kwargs):  # noqa: E501
        """create_state  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_state(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param dict(str, object) body:
        :return: InlineResponse2015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_state_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_state_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_state_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_state  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_state_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param dict(str, object) body:
        :return: InlineResponse2015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_state_type(self, project, **kwargs):  # noqa: E501
        """create_state_type  # noqa: E501

        Create or retrieve state types.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_state_type(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body21 body:
        :return: InlineResponse2016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_state_type_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_state_type_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_state_type_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_state_type  # noqa: E501

        Create or retrieve state types.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_state_type_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body21 body:
        :return: InlineResponse2016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_temporary_file(self, project, **kwargs):  # noqa: E501
        """create_temporary_file  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_temporary_file(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body23 body:
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_temporary_file_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_temporary_file_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_temporary_file_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_temporary_file  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_temporary_file_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body23 body:
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_temporary_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_temporary_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tree_leaf(self, project, **kwargs):  # noqa: E501
        """create_tree_leaf  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tree_leaf(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param dict(str, object) body:
        :return: InlineResponse2017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_tree_leaf_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_tree_leaf_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_tree_leaf_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_tree_leaf  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tree_leaf_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param dict(str, object) body:
        :return: InlineResponse2017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tree_leaf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_tree_leaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaves/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tree_leaf_type(self, project, **kwargs):  # noqa: E501
        """create_tree_leaf_type  # noqa: E501

        Interact with tree leaf type list.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tree_leaf_type(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body27 body:
        :return: InlineResponse2018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_tree_leaf_type_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_tree_leaf_type_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_tree_leaf_type_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_tree_leaf_type  # noqa: E501

        Interact with tree leaf type list.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tree_leaf_type_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body27 body:
        :return: InlineResponse2018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tree_leaf_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_tree_leaf_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeafTypes/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_version(self, project, **kwargs):  # noqa: E501
        """create_version  # noqa: E501

        Interact with a list of versions.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body32 body:
        :return: InlineResponse2019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_version_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.create_version_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def create_version_with_http_info(self, project, **kwargs):  # noqa: E501
        """create_version  # noqa: E501

        Interact with a list of versions.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_version_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body32 body:
        :return: InlineResponse2019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `create_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Versions/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_attribute_type(self, id, **kwargs):  # noqa: E501
        """delete_attribute_type  # noqa: E501

        Interact with an individual attribute type.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_attribute_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_attribute_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_attribute_type  # noqa: E501

        Interact with an individual attribute type.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_attribute_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_attribute_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_attribute_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AttributeType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_frame_association(self, id, **kwargs):  # noqa: E501
        """delete_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_frame_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_frame_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_frame_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_frame_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_frame_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_frame_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_frame_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/FrameAssociation/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job(self, run_uid, **kwargs):  # noqa: E501
        """delete_job  # noqa: E501

        Cancel a background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a job using the `run_uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job(run_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_uid: A uuid1 string identifying to single Job. (required)
        :return: InlineResponse2044
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_job_with_http_info(run_uid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_job_with_http_info(run_uid, **kwargs)  # noqa: E501
            return data

    def delete_job_with_http_info(self, run_uid, **kwargs):  # noqa: E501
        """delete_job  # noqa: E501

        Cancel a background job.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a job using the `run_uid` returned by either the `AlgorithmLaunch` or `Transcode` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_with_http_info(run_uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str run_uid: A uuid1 string identifying to single Job. (required)
        :return: InlineResponse2044
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['run_uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'run_uid' is set
        if ('run_uid' not in params or
                params['run_uid'] is None):
            raise ValueError("Missing the required parameter `run_uid` when calling `delete_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'run_uid' in params:
            path_params['run_uid'] = params['run_uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Job/{run_uid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2044',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_job_group(self, group_id, **kwargs):  # noqa: E501
        """delete_job_group  # noqa: E501

        Cancel a group of background jobs.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a group of jobs using the `group_id`  returned by either the `AlgorithmLaunch` or `Transcode` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_group(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: A uuid1 string identifying a group of jobs. (required)
        :return: InlineResponse2045
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_job_group_with_http_info(group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_job_group_with_http_info(group_id, **kwargs)  # noqa: E501
            return data

    def delete_job_group_with_http_info(self, group_id, **kwargs):  # noqa: E501
        """delete_job_group  # noqa: E501

        Cancel a group of background jobs.  Algorithms and transcodes create argo workflows that are annotated with two uuid1 strings, one identifying the run and the other identifying the group. Jobs that are submitted together have the same group id, but each workflow has a unique run id.  This endpoint allows the user to cancel a group of jobs using the `group_id`  returned by either the `AlgorithmLaunch` or `Transcode` endpoints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_job_group_with_http_info(group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str group_id: A uuid1 string identifying a group of jobs. (required)
        :return: InlineResponse2045
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_job_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `delete_job_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/JobGroup/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2045',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_localization(self, id, **kwargs):  # noqa: E501
        """delete_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_localization_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_localization_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_localization_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_localization" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_localization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_localization_association(self, id, **kwargs):  # noqa: E501
        """delete_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_localization_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_localization_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_localization_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_localization_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_localization_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationAssociation/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_localization_list(self, project, **kwargs):  # noqa: E501
        """delete_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse204
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_localization_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_localization_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def delete_localization_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """delete_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse204
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_localization_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `delete_localization_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse204',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_localization_type(self, id, **kwargs):  # noqa: E501
        """delete_localization_type  # noqa: E501

        Interact with an individual localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_localization_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_localization_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_localization_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_localization_type  # noqa: E501

        Interact with an individual localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_localization_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_localization_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_localization_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_media(self, id, **kwargs):  # noqa: E501
        """delete_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_media_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_media_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_media_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_media" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_media`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_media_list(self, project, **kwargs):  # noqa: E501
        """delete_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2041
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_media_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_media_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def delete_media_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """delete_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2041
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_media_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `delete_media_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2041',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_media_type(self, id, **kwargs):  # noqa: E501
        """delete_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_media_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_media_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_media_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_media_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_media_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_media_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_membership(self, id, **kwargs):  # noqa: E501
        """delete_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_membership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_membership_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_membership_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_membership_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_membership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_membership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_project(self, id, **kwargs):  # noqa: E501
        """delete_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_state(self, id, **kwargs):  # noqa: E501
        """delete_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_state_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_state_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_state_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_state_list(self, project, **kwargs):  # noqa: E501
        """delete_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2042
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_state_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_state_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def delete_state_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """delete_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2042
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_state_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `delete_state_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2042',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_state_type(self, id, **kwargs):  # noqa: E501
        """delete_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_state_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_state_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_state_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_state_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_temporary_file(self, id, **kwargs):  # noqa: E501
        """delete_temporary_file  # noqa: E501

        Interact with temporary file.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_temporary_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this temporary file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_temporary_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_temporary_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_temporary_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_temporary_file  # noqa: E501

        Interact with temporary file.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_temporary_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this temporary file. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_temporary_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_temporary_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFile/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_temporary_file_list(self, project, **kwargs):  # noqa: E501
        """delete_temporary_file_list  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_temporary_file_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int expired: If greater than 0 will return only expired files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_temporary_file_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_temporary_file_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def delete_temporary_file_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """delete_temporary_file_list  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_temporary_file_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int expired: If greater than 0 will return only expired files
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'expired']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_temporary_file_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `delete_temporary_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'expired' in params:
            query_params.append(('expired', params['expired']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tree_leaf(self, id, **kwargs):  # noqa: E501
        """delete_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_tree_leaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tree_leaf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_tree_leaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaf/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tree_leaf_list(self, project, **kwargs):  # noqa: E501
        """delete_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def delete_tree_leaf_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """delete_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'ancestor', 'type', 'name', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tree_leaf_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `delete_tree_leaf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in params:
            query_params.append(('ancestor', params['ancestor']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaves/{project}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tree_leaf_type(self, id, **kwargs):  # noqa: E501
        """delete_tree_leaf_type  # noqa: E501

        Interact with individual tree leaf type.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_tree_leaf_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_tree_leaf_type  # noqa: E501

        Interact with individual tree leaf type.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tree_leaf_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tree_leaf_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_tree_leaf_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeafType/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_version(self, id, **kwargs):  # noqa: E501
        """delete_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_version(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_version_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_version_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_version_with_http_info(self, id, **kwargs):  # noqa: E501
        """delete_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_version_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_algorithm_list(self, project, **kwargs):  # noqa: E501
        """get_algorithm_list  # noqa: E501

        Interact with algorithms that have been registered to a project.  For instructions on how to register an algorithm, visit `GitHub`_.  .. _GitHub:    https://github.com/cvisionai/tator/tree/master/examples/algorithms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse200]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_algorithm_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_algorithm_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_algorithm_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_algorithm_list  # noqa: E501

        Interact with algorithms that have been registered to a project.  For instructions on how to register an algorithm, visit `GitHub`_.  .. _GitHub:    https://github.com/cvisionai/tator/tree/master/examples/algorithms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_algorithm_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse200]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_algorithm_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_algorithm_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Algorithms/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse200]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_analysis_list(self, project, **kwargs):  # noqa: E501
        """get_analysis_list  # noqa: E501

        List analyses for a project.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analysis_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse2001]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_analysis_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_analysis_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_analysis_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_analysis_list  # noqa: E501

        List analyses for a project.  Analysis objects are used to display information about filtered media lists and/or annotations on the project detail page of the web UI. Currently only counting analysis is supported.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_analysis_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse2001]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_analysis_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_analysis_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Analyses/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2001]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attribute_type(self, id, **kwargs):  # noqa: E501
        """get_attribute_type  # noqa: E501

        Interact with an individual attribute type.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :return: Body1
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_attribute_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_attribute_type  # noqa: E501

        Interact with an individual attribute type.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :return: Body1
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attribute_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_attribute_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AttributeType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Body1',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attribute_type_list(self, project, **kwargs):  # noqa: E501
        """get_attribute_type_list  # noqa: E501

        Create or list attribute types.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_type_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int applies_to: Unique integer identifying the entity type that this attribute describes.
        :return: list[Object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_attribute_type_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_attribute_type_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_attribute_type_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_attribute_type_list  # noqa: E501

        Create or list attribute types.  Attribute types are used to define data types that describe entities. An attribute may give information about a media, localization, or state entity  in the form of a boolean, integer, float, string, enumeration, datetime,  or geoposition. Besides the data type, attribute types define attribute defaults, bounds, and other constraints.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_type_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int applies_to: Unique integer identifying the entity type that this attribute describes.
        :return: list[Object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'applies_to']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attribute_type_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_attribute_type_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'applies_to' in params:
            query_params.append(('applies_to', params['applies_to']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AttributeTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clip(self, id, frame_ranges, **kwargs):  # noqa: E501
        """get_clip  # noqa: E501

        Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clip(id, frame_ranges, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[str] frame_ranges: Comma-seperated list of frame ranges to capture. (required)
        :param int quality: Source resolution to use (default to highest quality)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clip_with_http_info(id, frame_ranges, **kwargs)  # noqa: E501
        else:
            (data) = self.get_clip_with_http_info(id, frame_ranges, **kwargs)  # noqa: E501
            return data

    def get_clip_with_http_info(self, id, frame_ranges, **kwargs):  # noqa: E501
        """get_clip  # noqa: E501

        Facility to get a clip from the server. Returns a temporary file object that expires in 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clip_with_http_info(id, frame_ranges, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[str] frame_ranges: Comma-seperated list of frame ranges to capture. (required)
        :param int quality: Source resolution to use (default to highest quality)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'frame_ranges', 'quality']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_clip`")  # noqa: E501
        # verify the required parameter 'frame_ranges' is set
        if ('frame_ranges' not in params or
                params['frame_ranges'] is None):
            raise ValueError("Missing the required parameter `frame_ranges` when calling `get_clip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'frame_ranges' in params:
            query_params.append(('frameRanges', params['frame_ranges']))  # noqa: E501
            collection_formats['frameRanges'] = 'csv'  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'video/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/GetClip/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_entity_type_schema(self, id, **kwargs):  # noqa: E501
        """get_entity_type_schema  # noqa: E501

        Output required fields for inserting a new object based on an EntityType.  Various REST calls take a polymorphic argument, which is dependent on what type is being added. This method provides a way to interrogate the service provider for what fields are required for a given addition.  The parameter to this function is the type id (i.e. the EntityTypeState or EntityTypeLocalization*** object that applies to a given media type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_entity_type_schema(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an entity type. (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_entity_type_schema_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_entity_type_schema_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_entity_type_schema_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_entity_type_schema  # noqa: E501

        Output required fields for inserting a new object based on an EntityType.  Various REST calls take a polymorphic argument, which is dependent on what type is being added. This method provides a way to interrogate the service provider for what fields are required for a given addition.  The parameter to this function is the type id (i.e. the EntityTypeState or EntityTypeLocalization*** object that applies to a given media type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_entity_type_schema_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an entity type. (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_entity_type_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_entity_type_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/EntityTypeSchema/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_frame(self, id, **kwargs):  # noqa: E501
        """get_frame  # noqa: E501

        Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frame(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] frames: Comma-seperated list of frames to capture.
        :param str tile: wxh, if not supplied is made as squarish as possible.
        :param str roi: w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
        :param int animate: If not tiling, animate each frame at a given fps in a gif.
        :param int quality: Source resolution to use (default to highest quality)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_frame_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_frame_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_frame_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_frame  # noqa: E501

        Facility to get a frame(jpg/png) of a given video frame, returns a square tile of frames based on the input parameter  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frame_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] frames: Comma-seperated list of frames to capture.
        :param str tile: wxh, if not supplied is made as squarish as possible.
        :param str roi: w:h:x:y, optionally crop each frame to a given roi in relative coordinates.
        :param int animate: If not tiling, animate each frame at a given fps in a gif.
        :param int quality: Source resolution to use (default to highest quality)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'frames', 'tile', 'roi', 'animate', 'quality']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_frame" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_frame`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'frames' in params:
            query_params.append(('frames', params['frames']))  # noqa: E501
            collection_formats['frames'] = 'csv'  # noqa: E501
        if 'tile' in params:
            query_params.append(('tile', params['tile']))  # noqa: E501
        if 'roi' in params:
            query_params.append(('roi', params['roi']))  # noqa: E501
        if 'animate' in params:
            query_params.append(('animate', params['animate']))  # noqa: E501
        if 'quality' in params:
            query_params.append(('quality', params['quality']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/GetFrame/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_frame_association(self, id, **kwargs):  # noqa: E501
        """get_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frame_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_frame_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_frame_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_frame_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_frame_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_frame_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_frame_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/FrameAssociation/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_localization(self, id, **kwargs):  # noqa: E501
        """get_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_localization_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_localization_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_localization_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_localization" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_localization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_localization_association(self, id, **kwargs):  # noqa: E501
        """get_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_localization_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_localization_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_localization_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_localization_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_localization_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationAssociation/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_localization_list(self, project, **kwargs):  # noqa: E501
        """get_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[Object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_localization_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_localization_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_localization_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[Object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_localization_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_localization_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_localization_type(self, id, **kwargs):  # noqa: E501
        """get_localization_type  # noqa: E501

        Interact with an individual localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_localization_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_localization_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_localization_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_localization_type  # noqa: E501

        Interact with an individual localization type.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_localization_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_localization_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_localization_type_list(self, project, **kwargs):  # noqa: E501
        """get_localization_type_list  # noqa: E501

        Create or retrieve localization types.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_type_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of unique integers identifying a media.
        :param int type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :return: list[InlineResponse2009]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_localization_type_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_localization_type_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_localization_type_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_localization_type_list  # noqa: E501

        Create or retrieve localization types.  A localization type is the metadata definition object for a localization. It includes shape, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_localization_type_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of unique integers identifying a media.
        :param int type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :return: list[InlineResponse2009]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_localization_type_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_localization_type_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse2009]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media(self, id, **kwargs):  # noqa: E501
        """get_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_media_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_media`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_list(self, project, **kwargs):  # noqa: E501
        """get_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20012]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_media_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20012]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_media_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20012]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_next(self, id, **kwargs):  # noqa: E501
        """get_media_next  # noqa: E501

        Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_next(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_next_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_next_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_media_next_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_media_next  # noqa: E501

        Retrieve ID of next media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the next media ID from the media passed as a path parameter. This allows iteration through a media list without serializing the entire list, which may be large.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_next_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_next" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_media_next`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaNext/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_prev(self, id, **kwargs):  # noqa: E501
        """get_media_prev  # noqa: E501

        Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_prev(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_prev_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_prev_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_media_prev_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_media_prev  # noqa: E501

        Retrieve ID of previous media in a media list.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the previous media ID from the media passed as a path parameter. This  allows iteration through a media list without serializing the entire list, which may be  large.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_prev_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media object. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_prev" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_media_prev`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaPrev/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_sections(self, project, **kwargs):  # noqa: E501
        """get_media_sections  # noqa: E501

        Retrieve media counts by section.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the number of images and videos per sections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_sections(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_sections_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_sections_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_media_sections_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_media_sections  # noqa: E501

        Retrieve media counts by section.  This endpoint accepts the same query parameters as a GET request to the `Medias` endpoint, but only returns the number of images and videos per sections.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_sections_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_sections" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_media_sections`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaSections/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_type(self, id, **kwargs):  # noqa: E501
        """get_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_media_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_media_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_media_type_list(self, project, **kwargs):  # noqa: E501
        """get_media_type_list  # noqa: E501

        Create or retrieve localization types.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_type_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20017]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_media_type_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_media_type_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_media_type_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_media_type_list  # noqa: E501

        Create or retrieve localization types.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_media_type_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20017]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_media_type_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_media_type_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20017]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_membership(self, id, **kwargs):  # noqa: E501
        """get_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_membership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_membership_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_membership_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_membership_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_membership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_membership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_membership_list(self, project, **kwargs):  # noqa: E501
        """get_membership_list  # noqa: E501

        Create or retrieve a list of project memberships.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_membership_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20020]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_membership_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_membership_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_membership_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_membership_list  # noqa: E501

        Create or retrieve a list of project memberships.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_membership_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20020]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_membership_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_membership_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Memberships/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20020]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project(self, id, **kwargs):  # noqa: E501
        """get_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_list(self, **kwargs):  # noqa: E501
        """get_project_list  # noqa: E501

        Interact with a list of projects.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Project lists return all projects that the requesting user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[InlineResponse20022]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_project_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_project_list_with_http_info(self, **kwargs):  # noqa: E501
        """get_project_list  # noqa: E501

        Interact with a list of projects.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Project lists return all projects that the requesting user has access to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[InlineResponse20022]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Projects', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20022]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_section_analysis(self, project, **kwargs):  # noqa: E501
        """get_section_analysis  # noqa: E501

        Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_analysis(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_section_analysis_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_section_analysis_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_section_analysis_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_section_analysis  # noqa: E501

        Retrieve analysis results for a media list.  This endpoint uses objects created with the `Analysis` endpoint to perform analysis on filtered media lists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_section_analysis_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: Unique integer identifying a media. Use this to do analyis on a single file instead of sections.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_section_analysis" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_section_analysis`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SectionAnalysis/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state(self, id, **kwargs):  # noqa: E501
        """get_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_state_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_list(self, project, **kwargs):  # noqa: E501
        """get_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20024]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_state_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20024]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_state_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20024]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_type(self, id, **kwargs):  # noqa: E501
        """get_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_state_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_state_type_list(self, project, **kwargs):  # noqa: E501
        """get_state_type_list  # noqa: E501

        Create or retrieve state types.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of unique integers identifying a media.
        :param int type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :return: list[InlineResponse20027]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_state_type_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_state_type_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_state_type_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_state_type_list  # noqa: E501

        Create or retrieve state types.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_state_type_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[int] media_id: List of unique integers identifying a media.
        :param int type: Deprecated. Use `LocalizationType` endpoint to retrieve individual localization type by ID.
        :return: list[InlineResponse20027]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id', 'type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_state_type_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_state_type_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20027]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_temporary_file(self, id, **kwargs):  # noqa: E501
        """get_temporary_file  # noqa: E501

        Interact with temporary file.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_temporary_file(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this temporary file. (required)
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_temporary_file_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_temporary_file_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_temporary_file_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_temporary_file  # noqa: E501

        Interact with temporary file.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_temporary_file_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: A unique integer value identifying this temporary file. (required)
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_temporary_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_temporary_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFile/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_temporary_file_list(self, project, **kwargs):  # noqa: E501
        """get_temporary_file_list  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_temporary_file_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int expired: If greater than 0 will return only expired files
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_temporary_file_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_temporary_file_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_temporary_file_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_temporary_file_list  # noqa: E501

        Interact with temporary file list.  Temporary files are files stored server side for a defined duration. The file must first be uploaded via tus, and can subsequently be saved using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_temporary_file_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int expired: If greater than 0 will return only expired files
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'expired']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_temporary_file_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_temporary_file_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'expired' in params:
            query_params.append(('expired', params['expired']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TemporaryFiles/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tree_leaf(self, id, **kwargs):  # noqa: E501
        """get_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_tree_leaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :return: InlineResponse20032
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree_leaf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_tree_leaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaf/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20032',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tree_leaf_list(self, project, **kwargs):  # noqa: E501
        """get_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20032]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_tree_leaf_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: list[InlineResponse20032]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'ancestor', 'type', 'name', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree_leaf_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_tree_leaf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in params:
            query_params.append(('ancestor', params['ancestor']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaves/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20032]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tree_leaf_type(self, id, **kwargs):  # noqa: E501
        """get_tree_leaf_type  # noqa: E501

        Interact with individual tree leaf type.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_tree_leaf_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_tree_leaf_type  # noqa: E501

        Interact with individual tree leaf type.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :return: InlineResponse20036
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree_leaf_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_tree_leaf_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeafType/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20036',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tree_leaf_type_list(self, project, **kwargs):  # noqa: E501
        """get_tree_leaf_type_list  # noqa: E501

        Interact with tree leaf type list.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_type_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20035]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tree_leaf_type_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tree_leaf_type_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def get_tree_leaf_type_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """get_tree_leaf_type_list  # noqa: E501

        Interact with tree leaf type list.  A tree leaf type is the metadata definition object for a tree leaf. It includes name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tree_leaf_type_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :return: list[InlineResponse20035]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tree_leaf_type_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `get_tree_leaf_type_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeafTypes/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20035]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, id, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_version(self, id, **kwargs):  # noqa: E501
        """get_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_version_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_version_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_version_with_http_info(self, id, **kwargs):  # noqa: E501
        """get_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_version_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :return: InlineResponse20040
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20040',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def notify(self, **kwargs):  # noqa: E501
        """notify  # noqa: E501

        Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.notify(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body36 body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.notify_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.notify_with_http_info(**kwargs)  # noqa: E501
            return data

    def notify_with_http_info(self, **kwargs):  # noqa: E501
        """notify  # noqa: E501

        Send a notification to administrators.  Uses the Slack API to send a notification to system administrators. This endpoint can only be used by system administrators and must be configured in a Tator deployment's settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.notify_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param Body36 body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method notify" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Notify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def partial_update_save_video_api(self, project, **kwargs):  # noqa: E501
        """partial_update_save_video_api  # noqa: E501

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the  `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. The script at `scripts/transcoder/transcodePipeline.py` in the Tator source code provides an example of how to transcode a Tator-compatible video, upload it, and save it to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_save_video_api(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param VideoUpdate body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.partial_update_save_video_api_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.partial_update_save_video_api_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def partial_update_save_video_api_with_http_info(self, project, **kwargs):  # noqa: E501
        """partial_update_save_video_api  # noqa: E501

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the  `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. The script at `scripts/transcoder/transcodePipeline.py` in the Tator source code provides an example of how to transcode a Tator-compatible video, upload it, and save it to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.partial_update_save_video_api_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param VideoUpdate body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method partial_update_save_video_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `partial_update_save_video_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveVideo/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def progress(self, project, **kwargs):  # noqa: E501
        """progress  # noqa: E501

        Broadcast progress update.  Progress messages are sent in the web UI via WebSocket, and are displayed as progress bars associated with individual media files and as a summary in the webpage header. All members of a project can see progress bars from uploads and background jobs initiated by other users within the project. This endpoint accepts an array of messages, allowing for progress messages to be batched into a single request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[Body37] body:
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.progress_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.progress_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def progress_with_http_info(self, project, **kwargs):  # noqa: E501
        """progress  # noqa: E501

        Broadcast progress update.  Progress messages are sent in the web UI via WebSocket, and are displayed as progress bars associated with individual media files and as a summary in the webpage header. All members of a project can see progress bars from uploads and background jobs initiated by other users within the project. This endpoint accepts an array of messages, allowing for progress messages to be batched into a single request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param list[Body37] body:
        :return: InlineResponse20043
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method progress" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `progress`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Progress/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20043',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_state_graphic_api(self, id, **kwargs):  # noqa: E501
        """retrieve_state_graphic_api  # noqa: E501

        Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_state_graphic_api(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :param str mode: Whether to animate or tile.
        :param float fps: Frame rate if `mode` is `animate`.
        :param str force_scale: wxh to force each tile prior to stich
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_state_graphic_api_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_state_graphic_api_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def retrieve_state_graphic_api_with_http_info(self, id, **kwargs):  # noqa: E501
        """retrieve_state_graphic_api  # noqa: E501

        Get frame(s) of a given localization-associated state.  Use the mode argument to control whether it is an animated gif or a tiled jpg.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_state_graphic_api_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :param str mode: Whether to animate or tile.
        :param float fps: Frame rate if `mode` is `animate`.
        :param str force_scale: wxh to force each tile prior to stich
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'mode', 'fps', 'force_scale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_state_graphic_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retrieve_state_graphic_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501
        if 'fps' in params:
            query_params.append(('fps', params['fps']))  # noqa: E501
        if 'force_scale' in params:
            query_params.append(('forceScale', params['force_scale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'image/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateGraphic/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_version_list(self, project, **kwargs):  # noqa: E501
        """retrieve_version_list  # noqa: E501

        Interact with a list of versions.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_version_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int media_id: Unique integer identifying a media.
        :return: list[InlineResponse20040]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_version_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_version_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def retrieve_version_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """retrieve_version_list  # noqa: E501

        Interact with a list of versions.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_version_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param int media_id: Unique integer identifying a media.
        :return: list[InlineResponse20040]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'media_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_version_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `retrieve_version_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Versions/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20040]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_image(self, project, **kwargs):  # noqa: E501
        """save_image  # noqa: E501

        Saves an uploaded image.  Media is uploaded via tus, a separate mechanism from the REST API. Once an image upload is complete, the image must be saved to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_image(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body38 body:
        :return: InlineResponse20111
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_image_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.save_image_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def save_image_with_http_info(self, project, **kwargs):  # noqa: E501
        """save_image  # noqa: E501

        Saves an uploaded image.  Media is uploaded via tus, a separate mechanism from the REST API. Once an image upload is complete, the image must be saved to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_image_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body38 body:
        :return: InlineResponse20111
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_image" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `save_image`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveImage/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20111',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def save_video(self, project, **kwargs):  # noqa: E501
        """save_video  # noqa: E501

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the  `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. The script at `scripts/transcoder/transcodePipeline.py` in the Tator source code provides an example of how to transcode a Tator-compatible video, upload it, and save it to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_video(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param VideoSpec body:
        :return: InlineResponse20112
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.save_video_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.save_video_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def save_video_with_http_info(self, project, **kwargs):  # noqa: E501
        """save_video  # noqa: E501

        Saves a transcoded video.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. To launch a transcode on raw uploaded video, use the  `Transcode` endpoint, which will create an Argo workflow to perform the transcode and save the video using this endpoint; no further REST calls are required. However, if you would like to perform transcodes locally, this endpoint enables that. The script at `scripts/transcoder/transcodePipeline.py` in the Tator source code provides an example of how to transcode a Tator-compatible video, upload it, and save it to the database using this endpoint.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.save_video_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param VideoSpec body:
        :return: InlineResponse20112
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method save_video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `save_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/SaveVideo/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20112',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transcode(self, project, **kwargs):  # noqa: E501
        """transcode  # noqa: E501

        Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `SaveVideo` endpoint. Optionally, depending on the `keep_original` field of the video  type specified by the `type` parameter, the originally uploaded file may also be saved. Note that the raw video must be uploaded first via tus, which is a separate mechanism  from the REST API. This endpoint requires a group and run UUID associated with this  upload. If no progress messages were generated during upload, then the group and run  UUIDs can be newly generated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcode(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body39 body:
        :return: InlineResponse20113
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.transcode_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.transcode_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def transcode_with_http_info(self, project, **kwargs):  # noqa: E501
        """transcode  # noqa: E501

        Start a transcode.  Videos in Tator must be transcoded to a multi-resolution streaming format before they can be viewed or annotated. This endpoint launches a transcode on raw uploaded video by creating an Argo workflow. The workflow will download the uploaded raw video, transcode it to the proper format, upload the transcoded video, and save the video using the  `SaveVideo` endpoint. Optionally, depending on the `keep_original` field of the video  type specified by the `type` parameter, the originally uploaded file may also be saved. Note that the raw video must be uploaded first via tus, which is a separate mechanism  from the REST API. This endpoint requires a group and run UUID associated with this  upload. If no progress messages were generated during upload, then the group and run  UUIDs can be newly generated.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.transcode_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body39 body:
        :return: InlineResponse20113
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transcode" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `transcode`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Transcode/{project}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20113',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def tree_leaf_suggestion(self, project, ancestor, query, **kwargs):  # noqa: E501
        """tree_leaf_suggestion  # noqa: E501

        Rest Endpoint compatible with devbridge suggestion format.  <https://github.com/kraaden/autocomplete>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tree_leaf_suggestion(project, ancestor, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia). (required)
        :param str query: String to search for matching names. (required)
        :param int min_level: Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
        :return: list[InlineResponse20031]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.tree_leaf_suggestion_with_http_info(project, ancestor, query, **kwargs)  # noqa: E501
        else:
            (data) = self.tree_leaf_suggestion_with_http_info(project, ancestor, query, **kwargs)  # noqa: E501
            return data

    def tree_leaf_suggestion_with_http_info(self, project, ancestor, query, **kwargs):  # noqa: E501
        """tree_leaf_suggestion  # noqa: E501

        Rest Endpoint compatible with devbridge suggestion format.  <https://github.com/kraaden/autocomplete>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.tree_leaf_suggestion_with_http_info(project, ancestor, query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia). (required)
        :param str query: String to search for matching names. (required)
        :param int min_level: Integer specifying level of results that may be returned. For example, 2 refers to grandchildren of the level specified by the `ancestor` parameter.
        :return: list[InlineResponse20031]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'ancestor', 'query', 'min_level']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tree_leaf_suggestion" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `tree_leaf_suggestion`")  # noqa: E501
        # verify the required parameter 'ancestor' is set
        if ('ancestor' not in params or
                params['ancestor'] is None):
            raise ValueError("Missing the required parameter `ancestor` when calling `tree_leaf_suggestion`")  # noqa: E501
        # verify the required parameter 'query' is set
        if ('query' not in params or
                params['query'] is None):
            raise ValueError("Missing the required parameter `query` when calling `tree_leaf_suggestion`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501
        if 'ancestor' in params:
            path_params['ancestor'] = params['ancestor']  # noqa: E501

        query_params = []
        if 'min_level' in params:
            query_params.append(('minLevel', params['min_level']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaves/Suggestion/{ancestor}/{project}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20031]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_attribute_type(self, id, **kwargs):  # noqa: E501
        """update_attribute_type  # noqa: E501

        Updates a localization type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_attribute_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :param Body2 body:
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_attribute_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_attribute_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_attribute_type  # noqa: E501

        Updates a localization type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_attribute_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an attribute type. (required)
        :param Body2 body:
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_attribute_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_attribute_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/AttributeType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_frame_association(self, id, **kwargs):  # noqa: E501
        """update_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_frame_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :param Body3 body:
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_frame_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_frame_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_frame_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_frame_association  # noqa: E501

        Modify a frame association.  Frame associations specify which frames that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_frame_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a frame association. (required)
        :param Body3 body:
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_frame_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_frame_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/FrameAssociation/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_localization(self, id, **kwargs):  # noqa: E501
        """update_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :param Body7 body:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_localization_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_localization_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_localization_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_localization  # noqa: E501

        Interact with single localization.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization. (required)
        :param Body7 body:
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_localization" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_localization`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localization/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_localization_association(self, id, **kwargs):  # noqa: E501
        """update_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_association(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param Body4 body:
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_localization_association_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_localization_association_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_localization_association_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_localization_association  # noqa: E501

        Modify a localization association.  Localization associations specify which localizations that a `State` object applies to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_association_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param Body4 body:
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_localization_association" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_localization_association`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationAssociation/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_localization_list(self, project, **kwargs):  # noqa: E501
        """update_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body6 body:
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_localization_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.update_localization_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def update_localization_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """update_localization_list  # noqa: E501

        Interact with list of localizations.  Localizations are shape annotations drawn on a video or image. They are currently of type box, line, or dot. Each shape has slightly different data members. Localizations are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body6 body:
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_localization_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `update_localization_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Localizations/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_localization_type(self, id, **kwargs):  # noqa: E501
        """update_localization_type  # noqa: E501

        Updates a localization type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :param Body9 body:
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_localization_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_localization_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_localization_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_localization_type  # noqa: E501

        Updates a localization type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_localization_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an localization type. (required)
        :param Body9 body:
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_localization_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_localization_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/LocalizationType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_media(self, id, **kwargs):  # noqa: E501
        """update_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :param Body11 body:
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_media_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_media_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_media_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_media  # noqa: E501

        Interact with individual media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a media. (required)
        :param Body11 body:
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_media" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_media`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Media/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_media_list(self, project, **kwargs):  # noqa: E501
        """update_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body10 body:
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_media_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.update_media_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def update_media_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """update_media_list  # noqa: E501

        Interact with list of media.  A media may be an image or a video. Media are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined localization attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  This endpoint does not include a POST method. Creating media must be preceded by an upload, after which a separate media creation endpoint must be called. The media creation endpoints are `Transcode` to launch a transcode of an uploaded video and `SaveImage` to save an uploaded image. If you would like to perform transcodes on local assets, you can use the `SaveVideo` endpoint to save an already transcoded video. Local transcodes may be performed with the script at `scripts/transcoder/transcodePipeline.py` in the Tator source code.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body10 body:
        :param list[int] media_id: List of integers identifying media.
        :param int type: Unique integer identifying media type.
        :param str name: Name of the media to filter on.
        :param str md5: MD5 sum of the media file.
        :param str after: If given, all results returned will be after the file with this filename. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body', 'media_id', 'type', 'name', 'md5', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_media_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `update_media_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'md5' in params:
            query_params.append(('md5', params['md5']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Medias/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_media_type(self, id, **kwargs):  # noqa: E501
        """update_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :param Body13 body:
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_media_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_media_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_media_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_media_type  # noqa: E501

        Interact with an individual media type.  A media type is the metadata definition object for media. It includes file format, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_media_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an media type. (required)
        :param Body13 body:
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_media_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_media_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/MediaType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_membership(self, id, **kwargs):  # noqa: E501
        """update_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_membership(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :param Body15 body:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_membership_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_membership_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_membership_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_membership  # noqa: E501

        Interact with an individual project membership.  Memberships specify a permission level of a user to a project. There are currently five cumulative permission levels. `View Only` can only view a project and not change any data. `Can Edit` can create, modify, and delete annotations. `Can Transfer` can upload and download media. `Can Execute` can launch algorithm workflows. `Full Control` can change project settings, including inviting new members, project name, and project metadata schema.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_membership_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a membership. (required)
        :param Body15 body:
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_membership" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_membership`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Membership/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_project(self, id, **kwargs):  # noqa: E501
        """update_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :param Body17 body:
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_project_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_project_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_project  # noqa: E501

        Interact with an individual project.  Projects are the object under which all data in Tator is grouped, including user access, metadata definitions, media, and annotations. Data does not cross boundaries between projects.  Only the project owner may patch or delete an individual project.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a project. (required)
        :param Body17 body:
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Project/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_state(self, id, **kwargs):  # noqa: E501
        """update_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :param Body20 body:
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_state_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_state_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_state_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_state  # noqa: E501

        Interact with an individual state.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a types of entity in Tator, meaning they can be described by user defined attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state. (required)
        :param Body20 body:
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_state" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_state`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/State/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_state_list(self, project, **kwargs):  # noqa: E501
        """update_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body19 body:
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_state_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.update_state_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def update_state_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """update_state_list  # noqa: E501

        Interact with list of states.  A state is a description of a collection of other objects. The objects a state describes could be media (image or video), video frames, or localizations. A state referring to a collection of localizations is often referred to as a track. States are a type of entity in Tator, meaning they can be described by user defined attributes.  This endpoint supports bulk patch of user-defined state attributes and bulk delete. Both are accomplished using the same query parameters used for a GET request.  It is importarant to know the fields required for a given entity_type_id as they are expected in the request data for this function. As an example, if the entity_type_id has attribute types associated with it named time and position, the JSON object must have them specified as keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body19 body:
        :param str media_query: Query string used to filter media IDs. If supplied, media_id will be ignored.
        :param list[int] media_id: Comma-separated list of media IDs.
        :param int type: Unique integer identifying a annotation type.
        :param int version: Unique integer identifying a version.
        :param int modified: Whether to return original or modified annotations, 0 or 1.
        :param int after: If given, all results returned will be after the localization with this ID. The `start` and `stop` parameters are relative to this modified range.
        :param str search: Lucene query syntax string for use with Elasticsearch. See `reference <https://lucene.apache.org/core/2_9_4/queryparsersyntax.html>`_.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body', 'media_query', 'media_id', 'type', 'version', 'modified', 'after', 'search', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_state_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `update_state_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'media_query' in params:
            query_params.append(('media_query', params['media_query']))  # noqa: E501
        if 'media_id' in params:
            query_params.append(('media_id', params['media_id']))  # noqa: E501
            collection_formats['media_id'] = 'csv'  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'modified' in params:
            query_params.append(('modified', params['modified']))  # noqa: E501
        if 'after' in params:
            query_params.append(('after', params['after']))  # noqa: E501
        if 'search' in params:
            query_params.append(('search', params['search']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/States/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_state_type(self, id, **kwargs):  # noqa: E501
        """update_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :param Body22 body:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_state_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_state_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_state_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_state_type  # noqa: E501

        Interact with an individual state type.  A state type is the metadata definition object for a state. It includes association type, name, description, and (like other entity types) may have any number of attribute types associated with it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_state_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a state type. (required)
        :param Body22 body:
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_state_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_state_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/StateType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tree_leaf(self, id, **kwargs):  # noqa: E501
        """update_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :param Body26 body:
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_tree_leaf_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_tree_leaf_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_tree_leaf  # noqa: E501

        Interact with individual tree leaf.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a tree leaf. (required)
        :param Body26 body:
        :return: InlineResponse20034
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tree_leaf" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_tree_leaf`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaf/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20034',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tree_leaf_list(self, project, **kwargs):  # noqa: E501
        """update_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf_list(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body25 body:
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
        else:
            (data) = self.update_tree_leaf_list_with_http_info(project, **kwargs)  # noqa: E501
            return data

    def update_tree_leaf_list_with_http_info(self, project, **kwargs):  # noqa: E501
        """update_tree_leaf_list  # noqa: E501

        Interact with a list of tree leaves.  Tree leaves are used to define label hierarchies that can be used for autocompletion of string attribute types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf_list_with_http_info(project, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project: A unique integer identifying a project. (required)
        :param Body25 body:
        :param str ancestor: Get descendents of a tree leaf element (inclusive), by path (i.e. ITIS.Animalia).
        :param int type: Unique integer identifying a tree leaf type.
        :param str name: Name of the tree leaf element.
        :param str attribute: Attribute equality filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lt: Attribute less than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_lte: Attribute less than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gt: Attribute greater than filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_gte: Attribute greater than or equal filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_contains: Attribute contains filter. Format is attribute1::value1,[attribute2::value2].
        :param str attribute_distance: Range filter for geoposition attributes. Format is attribute1::distance_km2::lat2::lon2,[attribute2::distancekm2::lat2::lon2].
        :param str attribute_null: Attribute null filter. Returns elements for which a given attribute is not defined.
        :param str operation: Set to \"count\" to return a count of objects instead of the objects.
        :param int start: Pagination start index. Index of the first item in a larger list to return.
        :param int stop: Pagination start index. Non-inclusive ndex of the last item in a larger list to return.
        :return: InlineResponse20033
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project', 'body', 'ancestor', 'type', 'name', 'attribute', 'attribute_lt', 'attribute_lte', 'attribute_gt', 'attribute_gte', 'attribute_contains', 'attribute_distance', 'attribute_null', 'operation', 'start', 'stop']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tree_leaf_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project' is set
        if ('project' not in params or
                params['project'] is None):
            raise ValueError("Missing the required parameter `project` when calling `update_tree_leaf_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project' in params:
            path_params['project'] = params['project']  # noqa: E501

        query_params = []
        if 'ancestor' in params:
            query_params.append(('ancestor', params['ancestor']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'attribute_lt' in params:
            query_params.append(('attribute_lt', params['attribute_lt']))  # noqa: E501
        if 'attribute_lte' in params:
            query_params.append(('attribute_lte', params['attribute_lte']))  # noqa: E501
        if 'attribute_gt' in params:
            query_params.append(('attribute_gt', params['attribute_gt']))  # noqa: E501
        if 'attribute_gte' in params:
            query_params.append(('attribute_gte', params['attribute_gte']))  # noqa: E501
        if 'attribute_contains' in params:
            query_params.append(('attribute_contains', params['attribute_contains']))  # noqa: E501
        if 'attribute_distance' in params:
            query_params.append(('attribute_distance', params['attribute_distance']))  # noqa: E501
        if 'attribute_null' in params:
            query_params.append(('attribute_null', params['attribute_null']))  # noqa: E501
        if 'operation' in params:
            query_params.append(('operation', params['operation']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'stop' in params:
            query_params.append(('stop', params['stop']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeaves/{project}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20033',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_tree_leaf_type(self, id, **kwargs):  # noqa: E501
        """update_tree_leaf_type  # noqa: E501

        Updates a tree leaf type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf_type(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :param Body28 body:
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_tree_leaf_type_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_tree_leaf_type_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_tree_leaf_type  # noqa: E501

        Updates a tree leaf type.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_tree_leaf_type_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying an tree_leaf type. (required)
        :param Body28 body:
        :return: InlineResponse20037
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_tree_leaf_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_tree_leaf_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/TreeLeafType/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20037',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param Body29 body:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param Body29 body:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param str username:
        :param str first_name:
        :param str last_name:
        :param str email:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param str username:
        :param str first_name:
        :param str last_name:
        :param str email:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'username', 'first_name', 'last_name', 'email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param str username:
        :param str first_name:
        :param str last_name:
        :param str email:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_user_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_user  # noqa: E501

        Interact with an individual user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_user_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a localization association. (required)
        :param str username:
        :param str first_name:
        :param str last_name:
        :param str email:
        :return: InlineResponse20038
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'username', 'first_name', 'last_name', 'email']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501
        if 'username' in params:
            form_params.append(('username', params['username']))  # noqa: E501
        if 'first_name' in params:
            form_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            form_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'email' in params:
            form_params.append(('email', params['email']))  # noqa: E501

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'text/plain'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20038',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_version(self, id, **kwargs):  # noqa: E501
        """update_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_version(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :param Body33 body:
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_version_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_version_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def update_version_with_http_info(self, id, **kwargs):  # noqa: E501
        """update_version  # noqa: E501

        Interact with individual version.  Versions allow for multiple \"layers\" of annotations on the same media. Versions are created at the project level, but are only displayed for a given media if that media contains annotations in that version. The version of an annotation can be set by providing it in a POST operation. Currently only localizations and states can have versions.  Versions are used in conjunction with the `modified` flag to determine whether an annotation should be displayed for a given media while annotating.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_version_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: A unique integer identifying a version. (required)
        :param Body33 body:
        :return: InlineResponse20041
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/Version/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20041',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def who_am_i(self, **kwargs):  # noqa: E501
        """who_am_i  # noqa: E501

        Returns the current user.  This is the equivalent of a whoami() operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.who_am_i(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.who_am_i_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.who_am_i_with_http_info(**kwargs)  # noqa: E501
            return data

    def who_am_i_with_http_info(self, **kwargs):  # noqa: E501
        """who_am_i  # noqa: E501

        Returns the current user.  This is the equivalent of a whoami() operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.who_am_i_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20039
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method who_am_i" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['TokenAuth']  # noqa: E501

        return self.api_client.call_api(
            '/rest/User/GetCurrent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20039',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
